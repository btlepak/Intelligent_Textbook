{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction to Operating Systems","text":"<p>Welcome! This site will serve as a guide for a collegiate level Introduction to Operating Systems course.  Much of the features of the site are created with or use an AI model, some of which may reqiure access to one of the popular LLMs (ChatGPT, Anthropic, Claude, etc.).</p> <p>Created by Benjamin Lepak</p> <p>Contact: lepak036@umn.edu</p> <p>Welcome to our Intelligent Textbooks with mkdocs material.</p> <p>This GitHub repository is used in the mkdocs-for-intelligent-texbooks tutoria here:</p> <p>Getting Started with Intelligent Textbooks</p>"},{"location":"cd/","title":"Course Description","text":"<p>Organization: University of Minnesota Department of Computer Science and Engineering (CSE) Course Identifier: CSCI 4061 Offering Course Title: : Introduction to Operating Systems</p>"},{"location":"cd/#course-overview","title":"Course Overview","text":"<p>This course provides an in-depth study of operating systems, focusing on their architecture, core functionalities, and role in managing computer hardware and software. Students will explore how operating systems allocate resources, manage processes, and facilitate user interaction. Key topics include process management, memory hierarchy, file systems, concurrency, and security. Through hands-on projects and assignments, students will work directly with operating system components, reinforcing both theoretical knowledge and practical skills essential for systems programming and software development.</p>"},{"location":"cd/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this course, students will be able to:</p> <ul> <li>Explain the purpose, structure, and design of modern operating systems.</li> <li>Analyze process management techniques, including scheduling, inter-process communication, and synchronization.</li> <li>Evaluate memory management strategies such as paging, segmentation, and virtual memory.</li> <li>Compare and contrast different file system architectures and storage management methods.</li> <li>Assess security models, access control mechanisms, and system protection strategies.</li> <li>Utilize system calls, shell scripting, and fundamental kernel-level programming techniques.</li> <li>Differentiate between major operating systems such as Linux, Windows, and macOS based on design and implementation.</li> </ul>"},{"location":"cd/#prerequisites","title":"Prerequisites","text":"<ul> <li>Grade of C- or Better in CSCI 2021 or EE 2361</li> <li>Admission to Computer Science Major or Minor, Computer    Engineering Major</li> </ul> <p>In addition to the formal prerequisites, a solid understanding of C programming is essential to completing this course. We will briefly survey aspects of C programming at the start of the course. However, if you are out of practice with C, you will need to thoroughly review this material. Suggested resources on C programming are available here.</p>"},{"location":"cd/#course-structure","title":"Course Structure","text":"<p>This course integrates theoretical and hands-on learning through: - Lectures: Covering essential concepts, case studies, and real-world applications. - Course Projects: Exploring system-level programming and operating system behavior. - Exams and Quizzes: Evaluating conceptual understanding and problem-solving skills. - Final Exam: Cumulative exam to test entire comprehension on course topics throughout the semester.</p>"},{"location":"cd/#topics-covered","title":"Topics Covered","text":"<ol> <li>Programs and Processes</li> <li>I/O Basics &amp; Redirection</li> <li>File Systems</li> <li>Virtual Memory</li> <li>Signals</li> <li>Pipes</li> <li>Shared Memory</li> <li>Sockets and Communication</li> <li>TCP &amp; UDP</li> <li>Threads</li> </ol>"},{"location":"cd/#expected-outcomes","title":"Expected Outcomes","text":"<p>Upon completion, students will have a comprehensive understanding of operating system principles and the skills necessary to analyze, debug, and optimize OS components. This foundation will prepare them for advanced topics such as systems programming, distributed computing, and cybersecurity.</p>"},{"location":"cd/#source","title":"Source","text":"<p>Much of this course description is from CSCI 4061 Intro to Operating Systems at the University of Minnesota - Twin Cities, taught by Jack Kolb.</p>"},{"location":"contact/","title":"Contact","text":"<p>For any further questions please contact Ben Lepak</p> <p>Thanks!</p>"},{"location":"glossary/","title":"Glossary of Terms","text":""},{"location":"glossary/#access-control","title":"Access Control","text":"<p>A method used to restrict access to system resources based on user identity or role. Access control determines which users or processes are authorized to access or modify data.</p>"},{"location":"glossary/#address-space","title":"Address Space","text":"<p>The range of memory addresses that a process can use. Each process has its own virtual address space isolated from others.</p>"},{"location":"glossary/#archive","title":"Archive","text":"<p>A file that contains a collection of other files and metadata, often used for storage or transfer. Example: <code>minitar</code> creates an archive of multiple files in a <code>.tar</code> format.</p>"},{"location":"glossary/#asynchronous-signal","title":"Asynchronous Signal","text":"<p>A signal delivered to a process at an unpredictable time, often in response to an external event like a keyboard interrupt.</p>"},{"location":"glossary/#atomic-operation","title":"Atomic Operation","text":"<p>An operation that completes without the possibility of interference from other operations. It is indivisible and guarantees consistency.</p>"},{"location":"glossary/#background-process","title":"Background Process","text":"<p>A process running independently of user interaction, typically started with an <code>&amp;</code> in Unix shells.</p>"},{"location":"glossary/#bss-segment","title":"BSS Segment","text":"<p>A region of memory used to store statically allocated variables that are declared but not initialized. Example: Uninitialized global variables reside in the BSS segment.</p>"},{"location":"glossary/#buffer","title":"Buffer","text":"<p>A temporary storage area used to hold data while it is being transferred between two locations.</p>"},{"location":"glossary/#child-process","title":"Child Process","text":"<p>A process created by another process (the parent) using a system call like <code>fork()</code>.</p>"},{"location":"glossary/#command-line-argument","title":"Command-Line Argument","text":"<p>An input value passed to a program at the time of execution, used to control program behavior. Example: <code>./minitar -c -f archive.tar file1.txt</code></p>"},{"location":"glossary/#condition-variable","title":"Condition Variable","text":"<p>A synchronization primitive used to block a thread until a particular condition is met.</p>"},{"location":"glossary/#context-switch","title":"Context Switch","text":"<p>The act of saving and restoring the state of a CPU so that execution can switch from one process or thread to another.</p>"},{"location":"glossary/#cpu-scheduling","title":"CPU Scheduling","text":"<p>The method by which the operating system decides which process or thread should be executed next on the CPU.</p>"},{"location":"glossary/#critical-section","title":"Critical Section","text":"<p>A section of code that must be executed by only one thread at a time to prevent race conditions.</p>"},{"location":"glossary/#daemon","title":"Daemon","text":"<p>A background process that runs without user interaction, often initiated at boot time to perform system-level tasks.</p>"},{"location":"glossary/#deadlock","title":"Deadlock","text":"<p>A condition where two or more processes are waiting for each other to release resources, resulting in a cycle that prevents progress.</p>"},{"location":"glossary/#directory","title":"Directory","text":"<p>A file that contains references to other files or directories, forming a hierarchical file structure.</p>"},{"location":"glossary/#disk-io","title":"Disk I/O","text":"<p>Operations involving reading from or writing to disk storage.</p>"},{"location":"glossary/#dynamic-memory-allocation","title":"Dynamic Memory Allocation","text":"<p>The process of allocating memory at runtime using functions like <code>malloc()</code>.</p>"},{"location":"glossary/#endianness","title":"Endianness","text":"<p>The byte order used to store data in memory. Common types are little-endian and big-endian.</p>"},{"location":"glossary/#environment-variable","title":"Environment Variable","text":"<p>A variable that defines system-wide or process-specific settings, accessible via the process's environment.</p>"},{"location":"glossary/#error-code","title":"Error Code","text":"<p>A numeric or symbolic value returned by a function or system call to indicate the outcome of an operation.</p>"},{"location":"glossary/#exit-status","title":"Exit Status","text":"<p>A value returned by a process when it terminates, used to signal success or failure to the parent process.</p>"},{"location":"glossary/#file-descriptor","title":"File Descriptor","text":"<p>An integer handle used by the operating system to identify an open file, socket, or pipe.</p>"},{"location":"glossary/#file-metadata","title":"File Metadata","text":"<p>Attributes of a file such as size, permissions, timestamps, and ownership.</p>"},{"location":"glossary/#file-pointer","title":"File Pointer","text":"<p>A pointer used to access a specific location in a file, typically used with the <code>fseek()</code> and <code>ftell()</code> functions.</p>"},{"location":"glossary/#file-system","title":"File System","text":"<p>A structure for organizing and storing files on a storage device.</p>"},{"location":"glossary/#fork","title":"Fork","text":"<p>A system call used to create a new process by duplicating the calling process.</p>"},{"location":"glossary/#free","title":"Free","text":"<p>A function used to deallocate memory previously allocated using <code>malloc()</code> or similar functions.</p>"},{"location":"glossary/#gdb","title":"GDB","text":"<p>The GNU Debugger, a tool used to debug C/C++ programs by inspecting variables and controlling program execution.</p>"},{"location":"glossary/#header-block","title":"Header Block","text":"<p>A 512-byte block in a tar archive that stores metadata for a file. Example: <code>fill_tar_header()</code> populates this structure in <code>minitar</code>.</p>"},{"location":"glossary/#heap","title":"Heap","text":"<p>A region of a process's memory used for dynamic memory allocation.</p>"},{"location":"glossary/#io-redirection","title":"I/O Redirection","text":"<p>The practice of changing the standard input/output of a command to read from or write to a file.</p>"},{"location":"glossary/#inode","title":"Inode","text":"<p>A data structure in a Unix file system that stores information about a file except its name.</p>"},{"location":"glossary/#interrupt","title":"Interrupt","text":"<p>A signal sent to the CPU to indicate an event that needs immediate attention.</p>"},{"location":"glossary/#ipc-inter-process-communication","title":"IPC (Inter-Process Communication)","text":"<p>Mechanisms provided by the OS to allow processes to communicate and synchronize.</p>"},{"location":"glossary/#kernel","title":"Kernel","text":"<p>The core component of an operating system responsible for managing hardware and system resources.</p>"},{"location":"glossary/#kernel-space","title":"Kernel Space","text":"<p>A protected memory region where the operating system kernel executes and manages operations.</p>"},{"location":"glossary/#linked-list","title":"Linked List","text":"<p>A dynamic data structure consisting of nodes that contain data and a pointer to the next node.</p>"},{"location":"glossary/#listener-socket","title":"Listener Socket","text":"<p>A socket that waits for incoming connection requests in a server program.</p>"},{"location":"glossary/#load-address","title":"Load Address","text":"<p>The starting address in memory where a program is loaded.</p>"},{"location":"glossary/#lock","title":"Lock","text":"<p>A mechanism that prevents concurrent access to a resource by multiple threads.</p>"},{"location":"glossary/#makefile","title":"Makefile","text":"<p>A script used to manage the build process of a project using the <code>make</code> utility. Example: <code>make test</code> runs all automated tests.</p>"},{"location":"glossary/#memory-leak","title":"Memory Leak","text":"<p>A condition where allocated memory is not properly deallocated, leading to wasted resources.</p>"},{"location":"glossary/#memory-mapping","title":"Memory Mapping","text":"<p>A technique that maps a file or device into memory so that file I/O can be treated as memory operations.</p>"},{"location":"glossary/#message-queue","title":"Message Queue","text":"<p>An IPC mechanism for sending and receiving messages between processes.</p>"},{"location":"glossary/#minitar","title":"Minitar","text":"<p>A simplified, POSIX-compliant implementation of the <code>tar</code> utility. Example: <code>minitar</code> can create and extract archive files.</p>"},{"location":"glossary/#mode","title":"Mode","text":"<p>A file attribute indicating read, write, and execute permissions.</p>"},{"location":"glossary/#mount-point","title":"Mount Point","text":"<p>A directory in which an additional file system is attached to the existing directory tree.</p>"},{"location":"glossary/#mutex","title":"Mutex","text":"<p>A mutual exclusion lock used to prevent simultaneous access to a resource.</p>"},{"location":"glossary/#named-pipe","title":"Named Pipe","text":"<p>A special file that acts as a conduit for communication between processes. Unlike anonymous pipes, named pipes have a name in the file system.</p>"},{"location":"glossary/#octal-notation","title":"Octal Notation","text":"<p>A base-8 numbering system often used to represent file permissions and tar metadata.</p>"},{"location":"glossary/#offset","title":"Offset","text":"<p>The position of a byte or block within a file or memory region.</p>"},{"location":"glossary/#orphan-process","title":"Orphan Process","text":"<p>A process whose parent has terminated, leaving it under the control of the <code>init</code> or <code>systemd</code> process.</p>"},{"location":"glossary/#page-fault","title":"Page Fault","text":"<p>An event triggered when a process accesses a part of its address space that is not currently in physical memory.</p>"},{"location":"glossary/#page-table","title":"Page Table","text":"<p>A data structure used by the memory management unit to map virtual addresses to physical addresses.</p>"},{"location":"glossary/#parent-process","title":"Parent Process","text":"<p>A process that creates one or more child processes.</p>"},{"location":"glossary/#path","title":"Path","text":"<p>A string that specifies the location of a file or directory in the file system hierarchy.</p>"},{"location":"glossary/#permissions","title":"Permissions","text":"<p>Attributes that define the access rights of users to files and directories.</p>"},{"location":"glossary/#pipe","title":"Pipe","text":"<p>A unidirectional communication channel between two processes.</p>"},{"location":"glossary/#pointer","title":"Pointer","text":"<p>A variable that holds the memory address of another variable.</p>"},{"location":"glossary/#posix","title":"Posix","text":"<p>A family of standards specified by IEEE to maintain compatibility between operating systems. Example: <code>minitar</code> follows the Posix archive format.</p>"},{"location":"glossary/#process","title":"Process","text":"<p>An independent execution unit with its own memory space, created using a system call like <code>fork()</code>.</p>"},{"location":"glossary/#process-table","title":"Process Table","text":"<p>A data structure maintained by the OS to track all running processes.</p>"},{"location":"glossary/#race-condition","title":"Race Condition","text":"<p>An undesirable effect where the outcome of a program depends on the timing of uncontrollable events.</p>"},{"location":"glossary/#read-system-call","title":"Read System Call","text":"<p>A system call used to read data from a file or input device.</p>"},{"location":"glossary/#recursion","title":"Recursion","text":"<p>A programming technique where a function calls itself to solve smaller sub-problems.</p>"},{"location":"glossary/#return-code","title":"Return Code","text":"<p>A value returned by a function or program indicating success or failure.</p>"},{"location":"glossary/#scheduler","title":"Scheduler","text":"<p>The OS component responsible for determining which process/thread runs at any given time.</p>"},{"location":"glossary/#semaphore","title":"Semaphore","text":"<p>A synchronization primitive that is used to control access to a common resource in concurrent systems.</p>"},{"location":"glossary/#shell","title":"Shell","text":"<p>A command-line interpreter that allows users to interact with the operating system.</p>"},{"location":"glossary/#signal","title":"Signal","text":"<p>A notification sent to a process to inform it of an event. Example: <code>SIGINT</code> interrupts a program from the terminal.</p>"},{"location":"glossary/#socket","title":"Socket","text":"<p>An endpoint for communication between two machines or processes over a network.</p>"},{"location":"glossary/#stack","title":"Stack","text":"<p>A region of memory used for function calls, storing return addresses, parameters, and local variables.</p>"},{"location":"glossary/#standard-input-stdin","title":"Standard Input (stdin)","text":"<p>The default source of input for a program, usually the keyboard.</p>"},{"location":"glossary/#standard-output-stdout","title":"Standard Output (stdout)","text":"<p>The default destination for output from a program, usually the terminal.</p>"},{"location":"glossary/#standard-error-stderr","title":"Standard Error (stderr)","text":"<p>The standard output stream used for error messages.</p>"},{"location":"glossary/#static-variable","title":"Static Variable","text":"<p>A variable that retains its value across function calls and has a fixed memory location.</p>"},{"location":"glossary/#strace","title":"Strace","text":"<p>A diagnostic tool that traces system calls made by a process.</p>"},{"location":"glossary/#swap-space","title":"Swap Space","text":"<p>Disk space used to supplement RAM by holding inactive pages of memory.</p>"},{"location":"glossary/#system-call","title":"System Call","text":"<p>A request from user space to the operating system to perform a privileged operation.</p>"},{"location":"glossary/#tar","title":"Tar","text":"<p>A Unix utility that combines multiple files into a single archive. <code>minitar</code> replicates this functionality in a simplified form.</p>"},{"location":"glossary/#tcp-transmission-control-protocol","title":"TCP (Transmission Control Protocol)","text":"<p>A reliable, connection-oriented protocol used for transmitting data over networks.</p>"},{"location":"glossary/#thread","title":"Thread","text":"<p>A lightweight process that shares memory with other threads in the same process.</p>"},{"location":"glossary/#time-sharing","title":"Time-Sharing","text":"<p>A method for allowing multiple processes to use the CPU by switching between them quickly.</p>"},{"location":"glossary/#tlb-translation-lookaside-buffer","title":"TLB (Translation Lookaside Buffer)","text":"<p>A cache used to reduce the time taken to access page table entries.</p>"},{"location":"glossary/#uid-user-identifier","title":"UID (User Identifier)","text":"<p>A numeric value that uniquely identifies a user on a Unix system.</p>"},{"location":"glossary/#unnamed-pipe","title":"Unnamed Pipe","text":"<p>A pipe created without a name in the file system, typically used for communication between a parent and child process.</p>"},{"location":"glossary/#update-operation","title":"Update Operation","text":"<p>A <code>minitar</code> operation that appends new versions of existing files in an archive.</p>"},{"location":"glossary/#user-space","title":"User Space","text":"<p>The portion of memory where user applications run, separate from kernel space.</p>"},{"location":"glossary/#virtual-address","title":"Virtual Address","text":"<p>An address used by a process that is translated to a physical address by the MMU.</p>"},{"location":"glossary/#virtual-memory","title":"Virtual Memory","text":"<p>An abstraction that allows processes to use more memory than physically available by using disk storage.</p>"},{"location":"glossary/#wait","title":"Wait","text":"<p>A system call used by a parent process to wait for its child to terminate.</p>"},{"location":"glossary/#write-system-call","title":"Write System Call","text":"<p>A system call used to write data to a file or output device.</p>"},{"location":"glossary/#zero-block","title":"Zero Block","text":"<p>A 512-byte block of zeros marking the end of a tar archive.</p>"},{"location":"references/","title":"References","text":"<p>Below is a list of key tools, technologies, and platforms referenced in the development and deployment of the intelligent textbook on Introduction to Operating Systems.</p>"},{"location":"references/#chatgpt","title":"ChatGPT","text":"<p>An AI LLM by OpenAI used to generate much of the content of the intelligent textbook.</p>"},{"location":"references/#mkdocs","title":"MkDocs","text":"<p>A static site generator used to build and render the intelligent textbook. It converts Markdown files into a styled documentation website.</p>"},{"location":"references/#mkdocs-material-theme","title":"MkDocs Material Theme","text":"<p>A highly customizable and feature-rich theme for MkDocs. It provided a clean, responsive layout and UI components such as tabs, callouts, and collapsible content blocks.</p>"},{"location":"references/#github-pages","title":"GitHub Pages","text":"<p>The hosting platform used to publish a MkDocs site directly from a GitHub repository, enabling a live version of the intelligent textbook.</p>"},{"location":"references/#markdown","title":"Markdown","text":"<p>The markup language used to write all textbook content, including chapters, labs, glossary entries, and project instructions in a readable and web-friendly format.</p>"},{"location":"references/#deploy-mkdocs-github-action","title":"Deploy MkDocs GitHub Action","text":"<p>A GitHub Action workflow used to automate the deployment of the textbook to GitHub Pages each time content is pushed to the repository.</p>"},{"location":"references/#gitbook","title":"GitBook","text":"<p>Referenced as an early inspiration for structuring technical content and educational material in a modular, navigable book format.</p>"},{"location":"references/#conda","title":"Conda","text":"<p>Used to manage the Python environment and dependencies for local MkDocs development and previewing the site before deployment.</p>"},{"location":"references/#visual-studio-code-vs-code","title":"Visual Studio Code (VS Code)","text":"<p>The primary code editor used to write, preview, and manage Markdown files, Git integration, and YAML configuration for the MkDocs site.</p>"},{"location":"references/#markdown-paste","title":"Markdown Paste","text":"<p>A VS Code extension that simplifies pasting and formatting rich content like images and tables into Markdown, improving writing workflow and visual content integration.</p>"},{"location":"chapters/10_threads/","title":"Chapter 10: Threads","text":""},{"location":"chapters/10_threads/#overview","title":"Overview","text":"<p>This chapter introduces threads, a key concept in concurrent programming. Threads allow a process to perform multiple tasks simultaneously by sharing the same memory space. In Unix-based systems, threads are widely used for building responsive and efficient applications.</p> <p>Key topics covered in this chapter include:</p> <ul> <li>What threads are and how they differ from processes</li> <li>Benefits and challenges of multithreading</li> <li>POSIX Threads (pthreads) API</li> <li>Creating, joining, and terminating threads</li> <li>Thread synchronization with mutexes and condition variables</li> <li>Common pitfalls and best practices</li> </ul>"},{"location":"chapters/10_threads/#what-are-threads","title":"What Are Threads?","text":"<p>A thread is a lightweight unit of execution within a process. All threads in a process share the same code, data, and heap segments but have separate stacks and registers.</p>"},{"location":"chapters/10_threads/#threads-vs-processes","title":"Threads vs. Processes","text":"Feature Thread Process Address Space Shared Separate Creation Overhead Low High Communication Fast (shared memory) Slow (IPC needed) Failure Isolation No Yes"},{"location":"chapters/10_threads/#posix-threads-pthreads","title":"POSIX Threads (pthreads)","text":"<p>The POSIX standard provides a powerful API for thread programming in C. To use it, include the <code>pthread.h</code> header and link with the <code>-pthread</code> flag.</p>"},{"location":"chapters/10_threads/#creating-threads","title":"Creating Threads","text":"<pre><code>#include &lt;pthread.h&gt;\n#include &lt;stdio.h&gt;\n\nvoid* say_hello(void* arg) {\n    printf(\"Hello from thread!\\n\");\n    return NULL;\n}\n\nint main() {\n    pthread_t tid;\n    pthread_create(&amp;tid, NULL, say_hello, NULL);\n    pthread_join(tid, NULL);\n    return 0;\n}\n</code></pre>"},{"location":"chapters/10_threads/#thread-synchronization","title":"Thread Synchronization","text":"<p>When multiple threads share data, synchronization is necessary to avoid race conditions.</p>"},{"location":"chapters/10_threads/#mutex-example","title":"Mutex Example","text":"<pre><code>#include &lt;pthread.h&gt;\n#include &lt;stdio.h&gt;\n\nint counter = 0;\npthread_mutex_t lock;\n\nvoid* increment(void* arg) {\n    for (int i = 0; i &lt; 10000; i++) {\n        pthread_mutex_lock(&amp;lock);\n        counter++;\n        pthread_mutex_unlock(&amp;lock);\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    pthread_mutex_init(&amp;lock, NULL);\n    pthread_create(&amp;t1, NULL, increment, NULL);\n    pthread_create(&amp;t2, NULL, increment, NULL);\n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    printf(\"Counter: %d\\n\", counter);\n    pthread_mutex_destroy(&amp;lock);\n    return 0;\n}\n</code></pre>"},{"location":"chapters/10_threads/#condition-variables","title":"Condition Variables","text":"<p>Condition variables allow threads to wait for specific conditions to occur.</p>"},{"location":"chapters/10_threads/#example-producer-consumer-pseudo-code","title":"Example: Producer-Consumer (Pseudo-code)","text":"<pre><code>pthread_mutex_t mutex;\npthread_cond_t cond;\n\npthread_mutex_lock(&amp;mutex);\nwhile (!condition_met)\n    pthread_cond_wait(&amp;cond, &amp;mutex);\n// Perform action\npthread_mutex_unlock(&amp;mutex);\n</code></pre>"},{"location":"chapters/10_threads/#thread-lifecycle","title":"Thread Lifecycle","text":"<ol> <li>Creation: <code>pthread_create()</code> starts a new thread.</li> <li>Execution: Thread runs the specified function.</li> <li>Synchronization: Use <code>pthread_join()</code> to wait for a thread to finish.</li> <li>Termination: Thread returns or calls <code>pthread_exit()</code>.</li> </ol>"},{"location":"chapters/10_threads/#common-pitfalls","title":"Common Pitfalls","text":"<ul> <li>Race conditions: Unsynchronized access to shared data.</li> <li>Deadlocks: Threads wait on each other indefinitely.</li> <li>Resource leaks: Not joining or cleaning up threads properly.</li> <li>Excessive thread creation: Leads to overhead and performance issues.</li> </ul>"},{"location":"chapters/10_threads/#interactive-quiz","title":"Interactive Quiz","text":"<ol> <li> <p>What is a key difference between threads and processes?</p> <p>A. Threads have separate memory spaces B. Threads share memory within a process C. Threads are heavier than processes</p> Show Answer <p>The correct answer is B. Threads share the same memory space, unlike processes.</p> </li> <li> <p>Which function is used to create a new thread in POSIX?</p> <p>A. <code>fork()</code> B. <code>pthread_create()</code> C. <code>exec()</code></p> Show Answer <p>The correct answer is B. <code>pthread_create()</code> creates a new thread.</p> </li> <li> <p>What is the purpose of a mutex?</p> <p>A. To execute threads in parallel B. To avoid context switching C. To ensure exclusive access to shared resources</p> Show Answer <p>The correct answer is C. Mutexes prevent race conditions by allowing only one thread to access a resource at a time.</p> </li> </ol>"},{"location":"chapters/10_threads/#summary","title":"Summary","text":"<ul> <li>Threads enable concurrent execution within a process and share memory.</li> <li>Use <code>pthread_create()</code>, <code>pthread_join()</code>, and <code>pthread_exit()</code> to manage threads.</li> <li>Synchronize threads with mutexes and condition variables to prevent race conditions.</li> <li>Proper design and cleanup are essential to avoid concurrency bugs.</li> </ul> <p>In the next chapter, we\u2019ll explore Process Scheduling and Synchronization, covering how the operating system manages threads and processes for efficient multitasking.</p> <p>This chapter is based on material from \"Advanced Programming in the UNIX Environment, Third Edition, by W. Richard Stevens and Stephen A. Rago, 2013.\"</p>"},{"location":"chapters/1_PandP/","title":"Chapter 1: Programs and Processes","text":""},{"location":"chapters/1_PandP/#overview","title":"Overview","text":"<p>This chapter introduces fundamental concepts related to programs and processes in Unix-based operating systems. Understanding the distinction between a program and a process is crucial for systems programming, as it forms the basis for process control, execution, and resource management in an operating system.</p> <p>A program is a passive entity that consists of executable code stored on disk. When a program is executed, the operating system creates a process, which is an active instance of that program with its own memory space, execution context, and system resources.</p> <p>Key topics covered in this chapter include: - The difference between programs and processes - The UNIX process model - Process creation and termination - Process memory layout - System calls related to process management</p>"},{"location":"chapters/1_PandP/#programs-vs-processes","title":"Programs vs. Processes","text":"<p>A program is a set of instructions stored in an executable file, while a process is an executing instance of a program. Multiple processes can be running from the same program, each with its own process ID (PID) and execution context. The operating system manages these processes, ensuring efficient CPU scheduling and resource allocation.</p>"},{"location":"chapters/1_PandP/#process-states","title":"Process States","text":"<p>A process transitions through several states during its execution:</p> <p></p> <ol> <li>New \u2013 The process is being created.</li> <li>Ready \u2013 The process is waiting to be assigned to a CPU.</li> <li>Running \u2013 The process is actively executing instructions.</li> <li>Blocked (Waiting) \u2013 The process is waiting for an event (e.g., I/O completion).</li> <li>Terminated \u2013 The process has finished execution or has been explicitly killed.</li> </ol>"},{"location":"chapters/1_PandP/#the-unix-process-model","title":"The UNIX Process Model","text":"<p>UNIX systems follow a hierarchical process model where every process (except the initial process, often <code>init</code> or <code>systemd</code>) is created by another process. This relationship forms a process tree, where each process has a parent and may create child processes.</p> <p></p>"},{"location":"chapters/1_PandP/#interactive-microsim","title":"Interactive MicroSim","text":"<p>Dive deeper into how <code>fork()</code>, <code>exec()</code>, <code>wait()</code>, and <code>exit()</code> affect the process tree with this interactive MicroSim:</p> <p>\ud83d\udc49 Launch the Process Tree Simulator</p> <p>The primary system calls for process management in UNIX include:</p> <ul> <li><code>fork()</code>: Creates a new child process by duplicating the parent.</li> <li><code>exec()</code>: Replaces the current process image with a new program.</li> <li><code>wait()</code>: Suspends execution of the parent until a child process terminates.</li> <li><code>exit()</code>: Terminates a process and returns a status to its parent.</li> </ul>"},{"location":"chapters/1_PandP/#example-creating-a-new-process","title":"Example: Creating a New Process","text":"<p>The <code>fork()</code> system call is fundamental in UNIX process creation. Below is a basic example in C:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) {\n        printf(\"Child Process: PID = %d\\n\", getpid());\n    } else {\n        printf(\"Parent Process: PID = %d, Child PID = %d\\n\", getpid(), pid);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"chapters/1_PandP/#process-memory-layout","title":"Process Memory Layout","text":"<p>Each process has a structured memory layout consisting of:</p> <p></p> <ul> <li>Text segment: The executable code.</li> <li>Data segment: Global and static variables.</li> <li>BSS (Block Started by Symbol): Uninitialized global and static variables.</li> <li>Heap: Dynamically allocated memory.</li> <li>Stack: Function call stack, containing local variables and return addresses.</li> <li>Kernel space: The portion of memory reserved for the operating system, which user processes do not have direct access to.</li> </ul>"},{"location":"chapters/1_PandP/#example-executing-a-new-program","title":"Example: Executing a New Program","text":"<p>The <code>exec()</code> family of functions replaces a running process with a new program:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    printf(\"Executing ls command...\\n\");\n    execl(\"/bin/ls\", \"ls\", \"-l\", NULL);\n    return 0;\n}\n</code></pre>"},{"location":"chapters/1_PandP/#process-termination","title":"Process Termination","text":"<p>Processes can terminate in various ways:</p> <ul> <li>Normal termination: The process completes execution and calls <code>exit()</code>.</li> <li>Signal termination: The process is terminated by a signal (e.g., <code>SIGKILL</code>).</li> <li>Parent-initiated termination: A parent process can terminate its child using <code>kill()</code>.</li> </ul>"},{"location":"chapters/1_PandP/#example-waiting-for-child-process-termination","title":"Example: Waiting for Child Process Termination","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) {\n        printf(\"Child Process\\n\");\n    } else {\n        wait(NULL);  // Parent waits for child to finish\n        printf(\"Child Process Terminated\\n\");\n    }\n    return 0;\n}\n</code></pre>"},{"location":"chapters/1_PandP/#interactive-quiz","title":"Interactive Quiz","text":"<p>Test your understanding of process management concepts with this short quiz:</p> <ol> <li> <p>What is the main difference between a program and a process?</p> <p>A. A program is running, while a process is stored on disk. B. A program is a passive entity, while a process is an executing instance of a program. C. A program always creates exactly one process.</p> Show Answer <p>The correct answer is B. A program is just a file containing executable code, but it does nothing on its own. When a program is executed, the operating system creates a process, which includes an allocated memory space, registers, and other runtime resources.</p> </li> <li> <p>Which system call is used to create a new process in UNIX?</p> <p>A. <code>exec()</code> B. <code>wait()</code> C. <code>fork()</code></p> Show Answer <p>The correct answer is C. The <code>fork()</code> system call creates a new child process by duplicating the parent\u2019s memory space. After a <code>fork()</code>, two processes exist: the parent and the newly created child.</p> </li> <li> <p>What happens when a parent process calls <code>wait()</code>?</p> <p>A. It immediately terminates. B. It waits for a child process to complete execution. C. It duplicates itself.</p> Show Answer <p>The correct answer is B. The <code>wait()</code> system call suspends the parent process until one of its child processes terminates, allowing the parent to retrieve the child\u2019s exit status.</p> </li> </ol>"},{"location":"chapters/1_PandP/#summary","title":"Summary","text":"<ul> <li>A program is an executable file, while a process is a running instance of a program.</li> <li>Processes undergo state transitions such as ready, running, blocked, and terminated.</li> <li>UNIX uses a hierarchical process model, where processes are created using <code>fork()</code> and executed with <code>exec()</code>.</li> <li>Process memory layout includes text, data, heap, and stack segments.</li> <li>Processes terminate normally with <code>exit()</code> or via signals from other processes.</li> </ul> <p>Understanding these concepts is essential for working with process management in UNIX environments. The next chapter will delve deeper into inter-process communication (IPC) mechanisms such as signals, pipes, and shared memory.</p> <p>This chapter is based on material from \"Advanced Programming in the UNIX Environment, Third Edition, by W. Richard Stevens and Stephen A. Rago, 2013.\"</p>"},{"location":"chapters/2_io/","title":"Chapter 2: I/O Basics &amp; Redirection","text":""},{"location":"chapters/2_io/#overview","title":"Overview","text":"<p>This chapter covers fundamental concepts of Input/Output (I/O) operations in Unix-based operating systems, with a focus on file descriptors, standard streams, and redirection techniques. Understanding how I/O works at the system level is crucial for efficient programming and automation.</p> <p>Key topics covered in this chapter include: - File descriptors and standard streams - System calls for I/O operations - Input and output redirection - Pipes and command chaining - Error handling in I/O operations</p>"},{"location":"chapters/2_io/#file-descriptors-and-standard-streams","title":"File Descriptors and Standard Streams","text":"<p>In Unix-like operating systems, every process interacts with files and devices through file descriptors, which are integer handles assigned by the kernel. The three standard file descriptors are:</p> File Descriptor Symbolic Name Description 0 <code>STDIN</code> Standard Input (keyboard by default) 1 <code>STDOUT</code> Standard Output (screen by default) 2 <code>STDERR</code> Standard Error (screen by default)"},{"location":"chapters/2_io/#example-writing-to-standard-output","title":"Example: Writing to Standard Output","text":"<p>The following C program demonstrates writing to <code>STDOUT</code> using <code>write()</code>:</p> <pre><code>#include &lt;unistd.h&gt;\nint main() {\n    write(1, \"Hello, World!\\n\", 14);\n    return 0;\n}\n</code></pre>"},{"location":"chapters/2_io/#system-calls-for-io-operations","title":"System Calls for I/O Operations","text":"<p>Unix provides system calls for low-level I/O operations:</p> <ul> <li><code>open()</code>: Opens a file and returns a file descriptor.</li> <li><code>read()</code>: Reads data from a file descriptor.</li> <li><code>write()</code>: Writes data to a file descriptor.</li> <li><code>close()</code>: Closes an open file descriptor.</li> </ul>"},{"location":"chapters/2_io/#example-reading-from-a-file","title":"Example: Reading from a File","text":"<p>The following C program reads from a file using <code>open()</code> and <code>read()</code>:</p> <pre><code>#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() {\n    char buffer[100];\n    int fd = open(\"file.txt\", O_RDONLY);\n    if (fd &lt; 0) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    read(fd, buffer, sizeof(buffer));\n    write(1, buffer, sizeof(buffer));\n    close(fd);\n    return 0;\n}\n</code></pre>"},{"location":"chapters/2_io/#input-and-output-redirection","title":"Input and Output Redirection","text":"<p>Unix shells allow redirection of standard streams:</p> <ul> <li><code>command &gt; file</code> \u2192 Redirects stdout to a file.</li> <li><code>command &lt; file</code> \u2192 Redirects stdin from a file.</li> <li><code>command 2&gt; file</code> \u2192 Redirects stderr to a file.</li> <li><code>command &gt;&gt; file</code> \u2192 Appends stdout to a file.</li> </ul>"},{"location":"chapters/2_io/#example-redirecting-output","title":"Example: Redirecting Output","text":"<p><pre><code>echo \"Hello, Unix!\" &gt; output.txt\n</code></pre> This command writes \"Hello, Unix!\" into <code>output.txt</code> instead of displaying it on the screen.</p>"},{"location":"chapters/2_io/#pipes-and-command-chaining","title":"Pipes and Command Chaining","text":"<p>Pipes (<code>|</code>) allow chaining of commands by redirecting the output of one command as the input of another.</p>"},{"location":"chapters/2_io/#example-using-a-pipe","title":"Example: Using a Pipe","text":"<p><pre><code>ls -l | grep \"txt\"\n</code></pre> This command lists files and filters results containing \"txt\".</p>"},{"location":"chapters/2_io/#error-handling-in-io","title":"Error Handling in I/O","text":"<p>Handling errors in I/O operations is crucial. The <code>perror()</code> function can be used in C to print error messages based on the global <code>errno</code> variable.</p>"},{"location":"chapters/2_io/#example-handling-file-opening-errors","title":"Example: Handling File Opening Errors","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;errno.h&gt;\n\nint main() {\n    int fd = open(\"nonexistent.txt\", O_RDONLY);\n    if (fd == -1) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"chapters/2_io/#interactive-quiz","title":"Interactive Quiz","text":"<p>Test your understanding of I/O basics and redirection:</p> <ol> <li> <p>Which file descriptor represents standard error?</p> <p>A. 0 B. 1 C. 2</p> Show Answer <p>The correct answer is C. File descriptor <code>2</code> represents <code>STDERR</code> (Standard Error).</p> </li> <li> <p>What does the command <code>ls &gt; output.txt</code> do?</p> <p>A. Lists files and prints to the terminal B. Lists files and saves output to <code>output.txt</code> C. Appends the list of files to <code>output.txt</code></p> Show Answer <p>The correct answer is B. The <code>&gt;</code> operator redirects <code>stdout</code> to <code>output.txt</code>, overwriting its contents.</p> </li> <li> <p>What does the <code>|</code> (pipe) symbol do in Unix?</p> <p>A. Creates a new process B. Redirects output of one command as input to another C. Reads a file line by line</p> Show Answer <p>The correct answer is B. Pipes allow the output of one command to be used as input for another command.</p> </li> </ol>"},{"location":"chapters/2_io/#summary","title":"Summary","text":"<ul> <li>Unix uses file descriptors (0: <code>STDIN</code>, 1: <code>STDOUT</code>, 2: <code>STDERR</code>) for I/O operations.</li> <li>System calls like <code>open()</code>, <code>read()</code>, <code>write()</code>, and <code>close()</code> manage file I/O.</li> <li>Redirection (<code>&gt;</code>, <code>&lt;</code>, <code>2&gt;</code>) allows controlling input and output.</li> <li>Pipes (<code>|</code>) enable chaining of commands.</li> <li>Error handling using <code>perror()</code> improves the robustness of I/O operations.</li> </ul> <p>Understanding these concepts is crucial for handling files and streams efficiently in Unix. The next chapter will explore File Systems and how Unix organizes and manages data storage.</p> <p>This chapter is based on material from \"Advanced Programming in the UNIX Environment, Third Edition, by W. Richard Stevens and Stephen A. Rago, 2013.\"</p>"},{"location":"chapters/3_fs/","title":"Chapter 3: File Systems","text":""},{"location":"chapters/3_fs/#overview","title":"Overview","text":"<p>This chapter explores the fundamentals of file systems in Unix-based operating systems, covering their structure, organization, and essential system calls. File systems are critical for data storage, retrieval, and management, providing a structured way to store and access files efficiently.</p> <p>Key topics covered in this chapter include:</p> <ul> <li>File system structure and organization</li> <li>File attributes and metadata</li> <li>Directory hierarchy and navigation</li> <li>File system types in Unix</li> <li>How files are stored and accessed</li> <li>System calls for file operations</li> <li>File permissions and access control</li> </ul>"},{"location":"chapters/3_fs/#file-system-structure-and-organization","title":"File System Structure and Organization","text":"<p>A file system organizes data into files and directories, providing a hierarchical structure for efficient storage and retrieval. Unix file systems follow a tree-like structure, starting from the root directory (<code>/</code>).</p>"},{"location":"chapters/3_fs/#key-components-of-a-file-system","title":"Key Components of a File System:","text":"<ul> <li>Files: The basic unit of storage, containing data or executable code.</li> <li>Directories: Containers that group files and other directories.</li> <li>Inodes: Data structures that store metadata about files.</li> <li>Superblock: Contains metadata about the file system, including its size and structure.</li> <li>Blocks: The smallest units of storage allocated for files.</li> </ul>"},{"location":"chapters/3_fs/#file-attributes-and-metadata","title":"File Attributes and Metadata","text":"<p>Each file in a Unix system has associated metadata stored in an inode. This metadata includes: - File type (regular file, directory, symbolic link, etc.) - Permissions (read, write, execute) - Owner and group - Size (in bytes) - Timestamps (creation, modification, and access times) - Number of hard links</p>"},{"location":"chapters/3_fs/#viewing-file-metadata","title":"Viewing File Metadata","text":"<p>To view file attributes, use the <code>ls -l</code> command: <pre><code>ls -l myfile.txt\n</code></pre> Example File Metadata:</p> <p></p>"},{"location":"chapters/3_fs/#directory-hierarchy-and-navigation","title":"Directory Hierarchy and Navigation","text":"<p>Unix file systems follow a hierarchical structure with a single root directory (<code>/</code>).</p> <p></p>"},{"location":"chapters/3_fs/#important-directories","title":"Important Directories:","text":"Directory Description <code>/</code> Root directory, contains all files and directories <code>/home/</code> User home directories <code>/etc/</code> System configuration files <code>/var/</code> Log files, temporary storage <code>/tmp/</code> Temporary files <code>/dev/</code> Device files <code>/mnt/</code> Mounted file systems"},{"location":"chapters/3_fs/#navigation-commands","title":"Navigation Commands:","text":"<pre><code>cd /home/user   # Change directory\nls -l           # List directory contents\npwd             # Print current working directory\nmkdir newdir    # Create a new directory\nrmdir olddir    # Remove an empty directory\n</code></pre>"},{"location":"chapters/3_fs/#how-files-are-stored-and-accessed","title":"How Files Are Stored and Accessed","text":"<p>Files in a Unix system are stored in blocks on a physical or virtual storage device. The file system manages how these blocks are allocated and retrieved.</p>"},{"location":"chapters/3_fs/#file-storage-process","title":"File Storage Process","text":"<ol> <li>File Creation: When a file is created, an inode is assigned to store metadata.</li> <li>Data Storage: The actual file contents are divided into blocks and stored in available disk space.</li> <li>Indexing with Inodes: The inode maintains a list of pointers to the blocks containing the file\u2019s data.</li> </ol>"},{"location":"chapters/3_fs/#accessing-files","title":"Accessing Files","text":"<p>When a file is accessed, the file system:</p> <ol> <li>Locates the inode using the directory structure.</li> <li>Reads the inode metadata to retrieve block locations.</li> <li>Retrieves the blocks and reconstructs the file contents.</li> </ol> <p></p>"},{"location":"chapters/3_fs/#interactive-microsim","title":"Interactive MicroSim","text":"<p>Explore how file descriptors, the open file table, and the inode table work together with this interactive MicroSim:</p> <p>\ud83d\udc49 Launch the File Access MicroSim</p>"},{"location":"chapters/3_fs/#file-system-types-in-unix","title":"File System Types in Unix","text":"<p>Unix supports multiple file system types, each optimized for different use cases:</p> <ul> <li>Ext4 \u2013 Default Linux file system with journaling support.</li> <li>XFS \u2013 High-performance file system for large-scale storage.</li> <li>ZFS \u2013 Advanced file system with built-in volume management.</li> <li>NFS \u2013 Network File System for remote file sharing.</li> <li>tmpfs \u2013 In-memory file system for temporary storage.</li> </ul>"},{"location":"chapters/3_fs/#system-calls-for-file-operations","title":"System Calls for File Operations","text":"<p>Unix provides system calls for direct file manipulation:</p> <ul> <li><code>open()</code>: Opens a file and returns a file descriptor.</li> <li><code>read()</code>: Reads data from a file descriptor.</li> <li><code>write()</code>: Writes data to a file descriptor.</li> <li><code>close()</code>: Closes an open file descriptor.</li> <li><code>stat()</code>: Retrieves file metadata.</li> </ul>"},{"location":"chapters/3_fs/#example-reading-a-file","title":"Example: Reading a File","text":"<pre><code>#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() {\n    char buffer[100];\n    int fd = open(\"file.txt\", O_RDONLY);\n    if (fd &lt; 0) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    read(fd, buffer, sizeof(buffer));\n    write(1, buffer, sizeof(buffer));\n    close(fd);\n    return 0;\n}\n</code></pre>"},{"location":"chapters/3_fs/#file-permissions-and-access-control","title":"File Permissions and Access Control","text":"<p>Unix uses a permission model to control access to files and directories. Each file has three permission sets:</p> <ul> <li>User (Owner)</li> <li>Group</li> <li>Others</li> </ul> <p>Permissions are represented using rwx notation:</p> <ul> <li><code>r</code> (read) \u2013 View file contents</li> <li><code>w</code> (write) \u2013 Modify file contents</li> <li><code>x</code> (execute) \u2013 Run a file as a program</li> </ul>"},{"location":"chapters/3_fs/#viewing-and-modifying-permissions","title":"Viewing and Modifying Permissions","text":"<pre><code>ls -l myfile.txt   # View file permissions\nchmod 755 myfile.txt   # Change permissions\nchown user:group myfile.txt   # Change file owner and group\n</code></pre>"},{"location":"chapters/3_fs/#interactive-quiz","title":"Interactive Quiz","text":"<p>Test your knowledge of file systems:</p> <ol> <li> <p>What command is used to display file metadata?</p> <p>A. <code>ls -l</code> B. <code>cat</code> C. <code>rm</code></p> Show Answer <p>The correct answer is A. The <code>ls -l</code> command lists detailed file information, including permissions, owner, and size.</p> </li> <li> <p>Which of the following is NOT a valid Unix file system type?</p> <p>A. Ext4 B. FAT32 C. XFS</p> Show Answer <p>The correct answer is B. FAT32 is a Windows file system, not commonly used in Unix systems.</p> </li> <li> <p>What does the <code>chmod 755 myfile.txt</code> command do?</p> <p>A. Grants full permissions to the owner and read/execute permissions to others B. Deletes the file C. Moves the file to another directory</p> Show Answer <p>The correct answer is A. <code>chmod 755</code> allows the owner full access (<code>rwx</code>) and read/execute access (<code>r-x</code>) for others.</p> </li> </ol>"},{"location":"chapters/3_fs/#summary","title":"Summary","text":"<ul> <li>Unix file systems store files using blocks and inodes.</li> <li>Metadata is stored separately in inodes.</li> <li>The Unix file system follows a hierarchical directory structure.</li> <li>File permissions protect data integrity and security.</li> </ul> <p>Understanding file systems is crucial for managing data efficiently. The next chapter will cover Virtual Memory and its role in memory management.</p> <p>This chapter is based on material from \"Advanced Programming in the UNIX Environment, Third Edition, by W. Richard Stevens and Stephen A. Rago, 2013.\"</p>"},{"location":"chapters/4_vm/","title":"Chapter 4: Virtual Memory","text":""},{"location":"chapters/4_vm/#overview","title":"Overview","text":"<p>This chapter explores the concept of virtual memory in Unix-based operating systems. Virtual memory is a memory management technique that creates an abstraction of the physical memory to provide processes with the illusion of a large, contiguous address space. It allows for more efficient use of hardware, process isolation, and simplified programming models.</p> <p>Key topics covered in this chapter include: - The purpose and benefits of virtual memory - Address translation and paging - Page tables and memory hierarchy - Demand paging and page faults - Swapping and memory protection - Tools and commands to inspect memory usage</p>"},{"location":"chapters/4_vm/#what-is-virtual-memory","title":"What is Virtual Memory?","text":"<p>Virtual memory allows each process to believe it has access to its own continuous block of memory, independent of other processes and the physical RAM available. This is achieved through address translation, where virtual addresses are mapped to physical addresses by the Memory Management Unit (MMU).</p>"},{"location":"chapters/4_vm/#benefits-of-virtual-memory","title":"Benefits of Virtual Memory","text":"<ul> <li>Process isolation: Each process operates in its own virtual address space.</li> <li>Efficient memory use: Not all program parts need to be loaded into RAM at once.</li> <li>Security: One process cannot directly access another process\u2019s memory.</li> <li>Simplified programming: Developers can write code as if there's unlimited memory.</li> </ul>"},{"location":"chapters/4_vm/#address-translation-and-paging","title":"Address Translation and Paging","text":"<p>To support virtual memory, operating systems use paging, where memory is divided into fixed-size blocks: - Pages: Blocks in virtual memory. - Frames: Blocks in physical memory.</p> <p>A page table maintains the mapping between pages and frames. Each process has its own page table managed by the OS.</p>"},{"location":"chapters/4_vm/#translation-process","title":"Translation Process","text":"<ol> <li>The CPU generates a virtual address.</li> <li>The MMU consults the page table to find the corresponding frame.</li> <li>The frame is used to retrieve the data from physical memory.</li> </ol>"},{"location":"chapters/4_vm/#example-page-table-entry","title":"Example: Page Table Entry","text":"<p>A page table entry might contain:</p> <ul> <li>Frame number</li> <li>Present/absent bit</li> <li>Access permissions (read/write/execute)</li> <li>Dirty bit (modified page)</li> </ul>"},{"location":"chapters/4_vm/#demand-paging-and-page-faults","title":"Demand Paging and Page Faults","text":"<p>In demand paging, only the required pages are loaded into memory. When a page is not present in memory and is needed by a process, a page fault occurs.</p>"},{"location":"chapters/4_vm/#handling-a-page-fault","title":"Handling a Page Fault","text":"<ol> <li>The OS suspends the process.</li> <li>It locates the required page on disk (swap space).</li> <li>Loads the page into a free frame.</li> <li>Updates the page table.</li> <li>Resumes the process.</li> </ol>"},{"location":"chapters/4_vm/#swapping-and-memory-protection","title":"Swapping and Memory Protection","text":"<p>When memory is full, the OS may swap out pages to disk to make room for new ones. Swapping is managed carefully to avoid excessive overhead (known as thrashing).</p> <p>Memory protection ensures that processes do not access each other's memory spaces. This is enforced through permission bits in page tables and by the MMU.</p>"},{"location":"chapters/4_vm/#example-memory-layout-with-virtual-address-space","title":"Example: Memory Layout with Virtual Address Space","text":"<p>Typical layout of a process\u2019s virtual memory:</p> <ul> <li>Text segment: Executable code (read-only)</li> <li>Data segment: Global/static variables</li> <li>BSS segment: Uninitialized data</li> <li>Heap: Dynamically allocated memory (grows upward)</li> <li>Stack: Function call stack (grows downward)</li> </ul>"},{"location":"chapters/4_vm/#interactive-microsim","title":"\ud83d\udcca Interactive MicroSim","text":"<p>Explore how virtual addresses are translated to physical memory using this interactive page table simulation:</p> <p>\ud83d\udc49 Launch the Virtual Memory Mapping MicroSim</p>"},{"location":"chapters/4_vm/#inspecting-memory-usage","title":"Inspecting Memory Usage","text":"<p>Unix-like systems provide tools to monitor and debug virtual memory:</p> <ul> <li><code>top</code> / <code>htop</code>: Display memory usage of processes</li> <li><code>vmstat</code>: Show system memory, CPU, and paging statistics</li> <li><code>pmap &lt;pid&gt;</code>: Display memory map of a specific process</li> <li><code>cat /proc/&lt;pid&gt;/maps</code>: Detailed memory segment info</li> </ul>"},{"location":"chapters/4_vm/#example","title":"Example:","text":"<p><pre><code>pmap 12345\n</code></pre> Output: <pre><code>12345: ./a.out\n0000000000400000     132K r-x-- a.out\n0000000000602000       4K rw--- a.out\n...\n</code></pre></p>"},{"location":"chapters/4_vm/#interactive-quiz","title":"Interactive Quiz","text":"<p>Test your understanding of virtual memory:</p> <ol> <li> <p>What is the main benefit of virtual memory?</p> <p>A. Faster CPU speeds B. Allows processes to share memory directly C. Provides process isolation and efficient memory use</p> </li> </ol> Show Answer <p>The correct answer is C. Virtual memory isolates process address spaces and allows efficient use of physical memory.</p> <ol> <li> <p>What happens during a page fault?</p> <p>A. The system reboots B. A missing page is loaded into memory from disk C. The process is terminated</p> </li> </ol> Show Answer <p>The correct answer is B. A page fault occurs when a required page is not in memory, prompting the OS to load it from disk.</p> <ol> <li> <p>Which command shows memory mappings of a running process?</p> <p>A. <code>ls</code> B. <code>ps</code> C. <code>pmap</code></p> </li> </ol> Show Answer <p>The correct answer is C. <code>pmap</code> displays the memory layout of a given process.</p>"},{"location":"chapters/4_vm/#summary","title":"Summary","text":"<ul> <li>Virtual memory provides an abstraction over physical memory using paging.</li> <li>Address translation is handled by the MMU and page tables.</li> <li>Demand paging loads memory on demand, triggering page faults as needed.</li> <li>Swapping and protection mechanisms help manage and secure memory.</li> <li>Tools like <code>pmap</code>, <code>vmstat</code>, and <code>/proc</code> help analyze virtual memory usage.</li> </ul> <p>Virtual memory is a cornerstone of modern OS design, supporting multitasking, stability, and scalability. In the next chapter, we'll explore Signals, a lightweight mechanism for inter-process communication and process control.</p> <p>This chapter is based on material from \"Advanced Programming in the UNIX Environment, Third Edition, by W. Richard Stevens and Stephen A. Rago, 2013.\"</p>"},{"location":"chapters/5_signals/","title":"Chapter 5: Signals","text":""},{"location":"chapters/5_signals/#overview","title":"Overview","text":"<p>This chapter introduces signals, a fundamental mechanism in Unix-based operating systems for inter-process communication (IPC) and asynchronous event handling. Signals are software interrupts delivered to a process to notify it of events such as exceptions, user input, or explicit inter-process messages.</p> <p>Key topics covered in this chapter include:</p> <ul> <li>What signals are and how they work</li> <li>Common standard signals</li> <li>Sending and receiving signals</li> <li>Signal handlers and default actions</li> <li>Blocking, ignoring, and handling signals</li> <li>Practical examples and best practices</li> </ul>"},{"location":"chapters/5_signals/#what-are-signals","title":"What Are Signals?","text":"<p>A signal is a limited form of inter-process communication used in Unix systems. It notifies a process that a specific event has occurred. Signals can be generated by the kernel, the user, or another process.</p>"},{"location":"chapters/5_signals/#characteristics-of-signals","title":"Characteristics of Signals:","text":"<ul> <li>Asynchronous: Signals can be delivered at any time.</li> <li>Lightweight: No data payload, just an integer ID.</li> <li>Limited scope: Signals carry no additional information beyond their identifier.</li> </ul>"},{"location":"chapters/5_signals/#common-signals","title":"Common Signals","text":"<p>Some of the most frequently used signals include:</p> Signal Name Description 1 <code>SIGHUP</code> Hangup detected 2 <code>SIGINT</code> Interrupt from keyboard (Ctrl+C) 9 <code>SIGKILL</code> Kill signal (cannot be caught) 15 <code>SIGTERM</code> Termination signal 17 <code>SIGCHLD</code> Child process terminated 18 <code>SIGCONT</code> Continue process execution 19 <code>SIGSTOP</code> Stop (cannot be caught) <p>To view all signals: <pre><code>kill -l\n</code></pre></p>"},{"location":"chapters/5_signals/#sending-signals","title":"Sending Signals","text":"<p>Signals can be sent using system calls or shell commands.</p>"},{"location":"chapters/5_signals/#shell-command","title":"Shell Command","text":"<p><pre><code>kill -SIGTERM &lt;pid&gt;\n</code></pre> Or using signal numbers: <pre><code>kill -15 &lt;pid&gt;\n</code></pre></p>"},{"location":"chapters/5_signals/#programmatically-in-c","title":"Programmatically (in C)","text":"<pre><code>#include &lt;signal.h&gt;\nkill(pid, SIGTERM);  // Sends SIGTERM to the process with given PID\n</code></pre>"},{"location":"chapters/5_signals/#handling-signals","title":"Handling Signals","text":"<p>By default, each signal has an associated default action, which might terminate the process, ignore the signal, or stop/resume the process.</p> <p>Programs can override these defaults by installing a signal handler using the <code>signal()</code> or <code>sigaction()</code> system call.</p>"},{"location":"chapters/5_signals/#example-handling-sigint","title":"Example: Handling SIGINT","text":"<p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;signal.h&gt;\n\nvoid handle_sigint(int sig) {\n    printf(\"Caught signal %d\\n\", sig);\n}\n\nint main() {\n    signal(SIGINT, handle_sigint);\n    while (1) {\n        printf(\"Running...\\n\");\n        sleep(1);\n    }\n    return 0;\n}\n</code></pre> Run the program and press <code>Ctrl+C</code> to see the handler in action.</p> <p></p>"},{"location":"chapters/5_signals/#blocking-and-ignoring-signals","title":"Blocking and Ignoring Signals","text":"<p>Processes can choose to block or ignore specific signals. Blocking a signal prevents it from being delivered until it is unblocked.</p>"},{"location":"chapters/5_signals/#blocking-example-with-sigprocmask","title":"Blocking Example with <code>sigprocmask()</code>","text":"<pre><code>#include &lt;signal.h&gt;\n\nsigset_t set;\nsigemptyset(&amp;set);\nsigaddset(&amp;set, SIGINT);\nsigprocmask(SIG_BLOCK, &amp;set, NULL);  // Block SIGINT\n</code></pre>"},{"location":"chapters/5_signals/#ignoring-a-signal","title":"Ignoring a Signal","text":"<pre><code>signal(SIGINT, SIG_IGN);  // Ignore SIGINT\n</code></pre>"},{"location":"chapters/5_signals/#useful-tools-and-debugging","title":"Useful Tools and Debugging","text":"<ul> <li><code>ps -l</code>: Shows signal masks of processes</li> <li><code>kill</code>: Sends signals to processes</li> <li><code>trap</code>: Shell builtin for signal handling in scripts</li> </ul>"},{"location":"chapters/5_signals/#shell-example-with-trap","title":"Shell Example with <code>trap</code>","text":"<pre><code>trap \"echo Caught SIGINT\" INT\nwhile true; do sleep 1; done\n</code></pre>"},{"location":"chapters/5_signals/#interactive-quiz","title":"Interactive Quiz","text":"<p>Test your understanding of signals:</p> <ol> <li> <p>What happens when a process receives <code>SIGKILL</code>?</p> <p>A. It handles the signal with a custom function B. It is forcibly terminated by the OS C. It ignores the signal</p> </li> </ol> Show Answer <p>The correct answer is B. <code>SIGKILL</code> cannot be caught or ignored; it forcibly terminates the process.</p> <ol> <li> <p>Which system call installs a signal handler in C?</p> <p>A. <code>send()</code> B. <code>signal()</code> C. <code>listen()</code></p> </li> </ol> Show Answer <p>The correct answer is B. <code>signal()</code> (or <code>sigaction()</code> for more control) installs a signal handler.</p> <ol> <li> <p>What does the <code>trap</code> command do in shell scripting?</p> <p>A. Blocks all signals B. Kills background processes C. Defines actions to take when receiving specific signals</p> </li> </ol> Show Answer <p>The correct answer is C. <code>trap</code> lets you handle signals like <code>SIGINT</code> in shell scripts.</p>"},{"location":"chapters/5_signals/#summary","title":"Summary","text":"<ul> <li>Signals provide lightweight IPC for notifying processes of events.</li> <li>Signals like <code>SIGINT</code>, <code>SIGTERM</code>, and <code>SIGKILL</code> are commonly used to control processes.</li> <li>Processes can handle, ignore, or block signals using system calls.</li> <li>Shells also support signal handling using the <code>trap</code> command.</li> </ul> <p>Signals are a critical building block in Unix systems for responsive, event-driven behavior. In the next chapter, we\u2019ll explore Pipes, another mechanism for process communication that allows data exchange between processes.</p> <p>This chapter is based on material from \"Advanced Programming in the UNIX Environment, Third Edition, by W. Richard Stevens and Stephen A. Rago, 2013.\"</p>"},{"location":"chapters/6_pipes/","title":"Chapter 6: Pipes","text":""},{"location":"chapters/6_pipes/#overview","title":"Overview","text":"<p>This chapter introduces pipes, a fundamental inter-process communication (IPC) mechanism in Unix-based operating systems. Pipes allow processes to communicate by passing data from one process\u2019s output to another\u2019s input. They are widely used in command-line environments and systems programming to create modular, efficient workflows.</p> <p>Key topics covered in this chapter include:</p> <ul> <li>What pipes are and how they work</li> <li>Anonymous vs. named pipes (FIFOs)</li> <li>Creating and using pipes in the shell</li> <li>Using pipes in C programs</li> <li>Synchronization and limitations</li> <li>Practical examples and debugging</li> </ul>"},{"location":"chapters/6_pipes/#what-are-pipes","title":"What Are Pipes?","text":"<p>A pipe is a unidirectional communication channel that connects the output of one process to the input of another. Pipes operate using file descriptors and allow for streaming data between processes.</p> <p></p>"},{"location":"chapters/6_pipes/#characteristics-of-pipes","title":"Characteristics of Pipes:","text":"<ul> <li>Unidirectional (one-way data flow)</li> <li>Use standard file descriptors (read/write)</li> <li>Temporary and exist only while the processes are alive (anonymous)</li> </ul>"},{"location":"chapters/6_pipes/#anonymous-pipes-in-the-shell","title":"Anonymous Pipes in the Shell","text":"<p>Anonymous pipes are created implicitly using the pipe (<code>|</code>) operator in the shell.</p>"},{"location":"chapters/6_pipes/#example-piping-commands","title":"Example: Piping Commands","text":"<p><pre><code>ls -l | grep \".txt\"\n</code></pre> In this example: - <code>ls -l</code> writes output to the pipe. - <code>grep \".txt\"</code> reads input from the pipe.</p>"},{"location":"chapters/6_pipes/#anonymous-pipes-in-c","title":"Anonymous Pipes in C","text":"<p>In C, you can create an anonymous pipe using the <code>pipe()</code> system call. The pipe is represented by two file descriptors:</p> <ul> <li><code>pipefd[0]</code>: Read end</li> <li><code>pipefd[1]</code>: Write end</li> </ul>"},{"location":"chapters/6_pipes/#example-basic-pipe-communication","title":"Example: Basic Pipe Communication","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    int pipefd[2];\n    char buffer[20];\n\n    pipe(pipefd);\n    write(pipefd[1], \"Hello, pipe!\", 12);\n    read(pipefd[0], buffer, 12);\n\n    printf(\"Received: %s\\n\", buffer);\n    return 0;\n}\n</code></pre>"},{"location":"chapters/6_pipes/#parent-child-communication-via-pipes","title":"Parent-Child Communication via Pipes","text":"<p>Pipes are often used between a parent and child process created using <code>fork()</code>.</p>"},{"location":"chapters/6_pipes/#example-parent-writes-child-reads","title":"Example: Parent writes, child reads","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    int pipefd[2];\n    pipe(pipefd);\n    pid_t pid = fork();\n\n    if (pid == 0) { // Child\n        close(pipefd[1]);\n        char msg[20];\n        read(pipefd[0], msg, sizeof(msg));\n        printf(\"Child received: %s\\n\", msg);\n    } else { // Parent\n        close(pipefd[0]);\n        char *msg = \"Data from parent\";\n        write(pipefd[1], msg, strlen(msg) + 1);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"chapters/6_pipes/#named-pipes-fifos","title":"Named Pipes (FIFOs)","text":"<p>Unlike anonymous pipes, named pipes (also known as FIFOs) exist as special files in the filesystem and allow unrelated processes to communicate.</p>"},{"location":"chapters/6_pipes/#creating-a-fifo","title":"Creating a FIFO","text":"<pre><code>mkfifo mypipe\n</code></pre>"},{"location":"chapters/6_pipes/#using-a-fifo","title":"Using a FIFO","text":"<pre><code>echo \"Message\" &gt; mypipe &amp;\ncat mypipe\n</code></pre>"},{"location":"chapters/6_pipes/#in-c","title":"In C:","text":"<pre><code>#include &lt;fcntl.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    mkfifo(\"mypipe\", 0666);\n    int fd = open(\"mypipe\", O_WRONLY);\n    write(fd, \"Hello FIFO\", 10);\n    close(fd);\n    return 0;\n}\n</code></pre>"},{"location":"chapters/6_pipes/#synchronization-and-limitations","title":"Synchronization and Limitations","text":"<ul> <li>Pipes are blocking by default: <code>read()</code> waits for data, <code>write()</code> waits for a reader.</li> <li>Pipes have a limited buffer size: Writing too much without reading may block.</li> <li>Pipes are unidirectional: Use two pipes for bidirectional communication.</li> </ul>"},{"location":"chapters/6_pipes/#interactive-quiz","title":"Interactive Quiz","text":"<p>Test your understanding of pipes:</p> <ol> <li> <p>What does the pipe (<code>|</code>) operator do in a Unix shell?</p> <p>A. Terminates a process B. Redirects output to a file C. Sends output of one command as input to another</p> </li> </ol> Show Answer <p>The correct answer is C. The pipe operator connects the <code>stdout</code> of one command to the <code>stdin</code> of the next.</p> <ol> <li> <p>Which system call creates an anonymous pipe in C?</p> <p>A. <code>open()</code> B. <code>pipe()</code> C. <code>dup2()</code></p> </li> </ol> Show Answer <p>The correct answer is B. The <code>pipe()</code> system call creates a unidirectional data channel.</p> <ol> <li> <p>What is the main difference between a pipe and a FIFO?</p> <p>A. Pipes are bidirectional B. FIFOs exist in the file system and can be used by unrelated processes C. Pipes allow data to persist after processes terminate</p> </li> </ol> Show Answer <p>The correct answer is B. FIFOs are named files that persist and can be used by unrelated processes.</p>"},{"location":"chapters/6_pipes/#summary","title":"Summary","text":"<ul> <li>Pipes allow simple, unidirectional communication between processes.</li> <li>Anonymous pipes are used between related processes and created with <code>pipe()</code>.</li> <li>Named pipes (FIFOs) can connect unrelated processes and exist in the file system.</li> <li>Pipes are commonly used for parent-child communication and shell scripting.</li> </ul> <p>In the next chapter, we will explore Shared Memory, a faster and more powerful IPC method that allows multiple processes to access common memory regions.</p> <p>This chapter is based on material from \"Advanced Programming in the UNIX Environment, Third Edition, by W. Richard Stevens and Stephen A. Rago, 2013.\"</p>"},{"location":"chapters/7_sm/","title":"Chapter 7: Shared Memory","text":""},{"location":"chapters/7_sm/#overview","title":"Overview","text":"<p>This chapter explores shared memory, one of the most efficient forms of inter-process communication (IPC) in Unix-based systems. Shared memory allows multiple processes to access a common memory region, making data exchange extremely fast compared to other IPC methods like pipes or message queues.</p> <p>Key topics covered in this chapter include:</p> <ul> <li>What shared memory is and how it works</li> <li>Advantages and limitations</li> <li>System calls for shared memory</li> <li>Creating and accessing shared memory segments</li> <li>Synchronization between processes</li> <li>Practical C examples and common use cases</li> </ul>"},{"location":"chapters/7_sm/#what-is-shared-memory","title":"What Is Shared Memory?","text":"<p>Shared memory allows processes to map the same region of physical memory into their virtual address spaces. Once mapped, processes can read from and write to the memory region without invoking the kernel for each operation.</p> <p></p>"},{"location":"chapters/7_sm/#benefits","title":"Benefits:","text":"<ul> <li>Speed: Data is exchanged without kernel intervention after setup.</li> <li>Flexibility: Ideal for large or frequent data transfers.</li> <li>Efficiency: Reduces overhead compared to other IPC mechanisms.</li> </ul>"},{"location":"chapters/7_sm/#limitations","title":"Limitations:","text":"<ul> <li>Requires synchronization (e.g., semaphores or mutexes)</li> <li>More complex setup and teardown</li> </ul>"},{"location":"chapters/7_sm/#system-calls-for-shared-memory-sysv-ipc","title":"System Calls for Shared Memory (SysV IPC)","text":"<p>System V shared memory uses the following system calls:</p> <ul> <li><code>shmget()</code>: Creates or accesses a shared memory segment.</li> <li><code>shmat()</code>: Attaches the shared segment to the process's address space.</li> <li><code>shmdt()</code>: Detaches the shared segment.</li> <li><code>shmctl()</code>: Controls operations on the segment (e.g., remove).</li> </ul>"},{"location":"chapters/7_sm/#example-creating-and-using-shared-memory-in-c","title":"Example: Creating and Using Shared Memory in C","text":"<p>This example demonstrates how a parent and child process can share memory:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/ipc.h&gt;\n#include &lt;sys/shm.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    int shmid;\n    char *shmaddr;\n\n    shmid = shmget(IPC_PRIVATE, 1024, IPC_CREAT | 0666);\n    if (shmid &lt; 0) {\n        perror(\"shmget\");\n        exit(1);\n    }\n\n    pid_t pid = fork();\n    if (pid == 0) {  // Child\n        sleep(1);  // Wait for parent to write\n        shmaddr = (char *)shmat(shmid, NULL, 0);\n        printf(\"Child read: %s\\n\", shmaddr);\n        shmdt(shmaddr);\n    } else {        // Parent\n        shmaddr = (char *)shmat(shmid, NULL, 0);\n        sprintf(shmaddr, \"Hello from parent!\");\n        shmdt(shmaddr);\n        wait(NULL);\n        shmctl(shmid, IPC_RMID, NULL);\n    }\n    return 0;\n}\n</code></pre> <p></p>"},{"location":"chapters/7_sm/#synchronization-and-safety","title":"Synchronization and Safety","text":"<p>Shared memory does not provide synchronization by itself. To safely coordinate access:</p> <ul> <li>Use semaphores or mutexes.</li> <li>Avoid race conditions by locking memory during access.</li> </ul>"},{"location":"chapters/7_sm/#example-with-pseudo-code","title":"Example with Pseudo Code:","text":"<pre><code>lock(mutex)\nwrite_to_shared_memory()\nunlock(mutex)\n</code></pre>"},{"location":"chapters/7_sm/#posix-shared-memory-alternative","title":"POSIX Shared Memory (Alternative)","text":"<p>POSIX provides a simpler API for shared memory via the following functions:</p> <ul> <li><code>shm_open()</code> and <code>ftruncate()</code> to create and size the segment</li> <li><code>mmap()</code> to map memory into the address space</li> <li><code>munmap()</code> and <code>shm_unlink()</code> to clean up</li> </ul> <pre><code>#include &lt;fcntl.h&gt;\n#include &lt;sys/mman.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    int fd = shm_open(\"/myshm\", O_CREAT | O_RDWR, 0666);\n    ftruncate(fd, 4096);\n    char *addr = mmap(0, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    sprintf(addr, \"Hello POSIX shared memory\");\n    munmap(addr, 4096);\n    shm_unlink(\"/myshm\");\n    return 0;\n}\n</code></pre>"},{"location":"chapters/7_sm/#interactive-quiz","title":"Interactive Quiz","text":"<p>Test your understanding of shared memory:</p> <ol> <li> <p>What is a key advantage of shared memory over pipes?</p> <p>A. Shared memory is slower B. Shared memory supports signal handling C. Shared memory enables faster data exchange</p> Show Answer <p>The correct answer is C. Shared memory allows fast, direct access to memory without kernel mediation.</p> </li> <li> <p>What function attaches a SysV shared memory segment?</p> <p>A. <code>shmctl()</code> B. <code>shmat()</code> C. <code>shmget()</code></p> Show Answer <p>The correct answer is B. <code>shmat()</code> attaches the shared memory segment to the process\u2019s address space.</p> </li> <li> <p>Which API is used for POSIX shared memory?</p> <p>A. <code>open()</code> and <code>read()</code> B. <code>shmget()</code> and <code>shmat()</code> C. <code>shm_open()</code> and <code>mmap()</code></p> Show Answer <p>The correct answer is C. POSIX shared memory uses <code>shm_open()</code> and <code>mmap()</code> for memory management.</p> </li> </ol>"},{"location":"chapters/7_sm/#summary","title":"Summary","text":"<ul> <li>Shared memory enables efficient IPC by allowing multiple processes to access the same memory.</li> <li>SysV and POSIX are two main shared memory APIs.</li> <li>Synchronization (e.g., semaphores) is essential for safe usage.</li> <li>Shared memory is ideal for high-performance applications and concurrent processing.</li> </ul> <p>In the next chapter, we will explore Sockets and Communication, which enable communication between processes across systems or networks.</p> <p>This chapter is based on material from \"Advanced Programming in the UNIX Environment, Third Edition, by W. Richard Stevens and Stephen A. Rago, 2013.\"</p>"},{"location":"chapters/8_SandC/","title":"Chapter 8: Sockets and Communication","text":""},{"location":"chapters/8_SandC/#overview","title":"Overview","text":"<p>This chapter introduces sockets, a powerful inter-process communication (IPC) mechanism that enables data exchange between processes over a network or locally on the same system. Sockets are the foundation of modern network programming and are used to implement protocols like TCP and UDP.</p> <p>Key topics covered in this chapter include:</p> <ul> <li>What sockets are and how they work</li> <li>TCP vs. UDP sockets</li> <li>Creating client-server programs in C</li> <li>Using <code>socket()</code>, <code>bind()</code>, <code>listen()</code>, <code>accept()</code>, <code>connect()</code></li> <li>Socket address structures</li> <li>Example code and debugging tools</li> </ul>"},{"location":"chapters/8_SandC/#what-are-sockets","title":"What Are Sockets?","text":"<p>A socket is an abstraction representing an endpoint for communication. A pair of sockets forms a communication channel. Sockets can be used for:</p> <ul> <li>Inter-machine communication (across networks)</li> <li>Local IPC (via Unix domain sockets)</li> </ul> <p></p>"},{"location":"chapters/8_SandC/#socket-types","title":"Socket Types","text":"Type Protocol Characteristics <code>SOCK_STREAM</code> TCP Reliable, connection-oriented <code>SOCK_DGRAM</code> UDP Unreliable, connectionless <code>SOCK_SEQPACKET</code> Sequenced packets (rarely used) Connection-oriented with message boundaries"},{"location":"chapters/8_SandC/#tcp-vs-udp","title":"TCP vs. UDP","text":"Feature TCP UDP Reliability \u2714 Yes \u2718 No Connection \u2714 Required (<code>connect</code>) \u2718 Not required Ordered Delivery \u2714 Yes \u2718 No guarantee Speed Slower Faster Use Case Web, Email, File Transfer DNS, Streaming, Gaming"},{"location":"chapters/8_SandC/#creating-a-tcp-server-in-c","title":"Creating a TCP Server in C","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    int server_fd, client_fd;\n    struct sockaddr_in addr;\n    char buffer[1024] = {0};\n\n    server_fd = socket(AF_INET, SOCK_STREAM, 0);\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = INADDR_ANY;\n    addr.sin_port = htons(8080);\n\n    bind(server_fd, (struct sockaddr *)&amp;addr, sizeof(addr));\n    listen(server_fd, 5);\n    client_fd = accept(server_fd, NULL, NULL);\n\n    read(client_fd, buffer, 1024);\n    printf(\"Received: %s\\n\", buffer);\n    write(client_fd, \"Hello from server\", 18);\n\n    close(client_fd);\n    close(server_fd);\n    return 0;\n}\n</code></pre>"},{"location":"chapters/8_SandC/#creating-a-tcp-client-in-c","title":"Creating a TCP Client in C","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;arpa/inet.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    struct sockaddr_in addr;\n\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(8080);\n    inet_pton(AF_INET, \"127.0.0.1\", &amp;addr.sin_addr);\n\n    connect(sock, (struct sockaddr *)&amp;addr, sizeof(addr));\n    send(sock, \"Hello server\", 12, 0);\n\n    char buffer[1024] = {0};\n    read(sock, buffer, 1024);\n    printf(\"Server replied: %s\\n\", buffer);\n\n    close(sock);\n    return 0;\n}\n</code></pre>"},{"location":"chapters/8_SandC/#socket-system-calls","title":"Socket System Calls","text":"<ul> <li><code>socket()</code>: Creates a new socket.</li> <li><code>bind()</code>: Binds socket to a local address.</li> <li><code>listen()</code>: Prepares socket to accept incoming connections.</li> <li><code>accept()</code>: Accepts a connection from a client.</li> <li><code>connect()</code>: Connects to a server.</li> <li><code>read()</code> / <code>write()</code> / <code>recv()</code> / <code>send()</code>: Communication functions.</li> <li><code>close()</code>: Closes the socket.</li> </ul>"},{"location":"chapters/8_SandC/#address-structures","title":"Address Structures","text":"<p>Sockets use <code>struct sockaddr_in</code> for IPv4: <pre><code>struct sockaddr_in {\n    short sin_family;      // Address family (AF_INET)\n    unsigned short sin_port;  // Port number\n    struct in_addr sin_addr;  // IP address\n};\n</code></pre></p> <p>Use <code>inet_pton()</code> to convert a string IP address into binary: <pre><code>inet_pton(AF_INET, \"127.0.0.1\", &amp;addr.sin_addr);\n</code></pre></p>"},{"location":"chapters/8_SandC/#debugging-and-tools","title":"Debugging and Tools","text":"<ul> <li><code>netstat -an</code>: View open ports and socket states</li> <li><code>lsof -i</code>: List processes using network sockets</li> <li><code>nc</code> (netcat): Simple client/server testing</li> <li><code>tcpdump</code> or <code>wireshark</code>: Packet sniffing tools</li> </ul>"},{"location":"chapters/8_SandC/#interactive-quiz","title":"Interactive Quiz","text":"<p>Test your understanding of sockets:</p> <ol> <li> <p>What does <code>socket(AF_INET, SOCK_STREAM, 0)</code> create?</p> <p>A. A UDP socket B. A TCP socket C. A raw socket</p> Show Answer <p>The correct answer is B. <code>SOCK_STREAM</code> with <code>AF_INET</code> creates a TCP socket.</p> </li> <li> <p>Which function is used by a server to wait for a connection?</p> <p>A. <code>connect()</code> B. <code>accept()</code> C. <code>recv()</code></p> Show Answer <p>The correct answer is B. The server uses <code>accept()</code> to wait for a client connection.</p> </li> <li> <p>What is the main difference between TCP and UDP?</p> <p>A. UDP is more reliable B. TCP is connectionless C. TCP guarantees delivery, UDP does not</p> Show Answer <p>The correct answer is C. TCP ensures reliable delivery; UDP does not.</p> </li> </ol>"},{"location":"chapters/8_SandC/#summary","title":"Summary","text":"<ul> <li>Sockets provide flexible and powerful IPC for local and network communication.</li> <li>TCP is reliable and connection-based; UDP is faster but connectionless.</li> <li>System calls like <code>socket()</code>, <code>bind()</code>, <code>accept()</code>, and <code>connect()</code> manage socket communication.</li> <li>Understanding the socket lifecycle is essential for building robust network programs.</li> </ul> <p>In the next chapter, we\u2019ll explore TCP &amp; UDP in greater depth, comparing their APIs, performance, and real-world use cases.</p> <p>This chapter is based on material from \"Advanced Programming in the UNIX Environment, Third Edition, by W. Richard Stevens and Stephen A. Rago, 2013.\"</p>"},{"location":"chapters/9_tcpudp/","title":"Chapter 9: TCP &amp; UDP","text":""},{"location":"chapters/9_tcpudp/#overview","title":"Overview","text":"<p>This chapter explores TCP (Transmission Control Protocol) and UDP (User Datagram Protocol), the two primary transport-layer protocols used in network programming. Understanding their differences, behavior, and appropriate use cases is essential for building reliable and efficient networked applications.</p> <p>Key topics covered in this chapter include:</p> <ul> <li>Introduction to TCP and UDP</li> <li>Protocol features and differences</li> <li>Socket programming with TCP vs. UDP</li> <li>Packet structure and communication flow</li> <li>When to use TCP or UDP</li> <li>Examples in C and common debugging tools</li> </ul>"},{"location":"chapters/9_tcpudp/#introduction-to-tcp-and-udp","title":"Introduction to TCP and UDP","text":"<p>TCP and UDP are protocols used for sending data over networks. They sit above the IP layer in the protocol stack and differ primarily in how they handle reliability, ordering, and connection management.</p> <p></p>"},{"location":"chapters/9_tcpudp/#tcp-transmission-control-protocol","title":"TCP: Transmission Control Protocol","text":"<p>TCP is a connection-oriented, reliable, and stream-based protocol. It ensures data is delivered in order and without duplication.</p>"},{"location":"chapters/9_tcpudp/#key-tcp-features","title":"Key TCP Features:","text":"<ul> <li>Connection establishment (3-way handshake)</li> <li>Reliable delivery with acknowledgments</li> <li>Flow and congestion control</li> <li>Ordered byte stream</li> </ul>"},{"location":"chapters/9_tcpudp/#tcp-communication-flow","title":"TCP Communication Flow:","text":"<ol> <li>Client calls <code>connect()</code> to initiate communication.</li> <li>Server calls <code>listen()</code> and <code>accept()</code> to establish the connection.</li> <li>Data is exchanged using <code>send()</code> and <code>recv()</code>.</li> <li>The connection is closed using <code>close()</code>.</li> </ol>"},{"location":"chapters/9_tcpudp/#udp-user-datagram-protocol","title":"UDP: User Datagram Protocol","text":"<p>UDP is a connectionless, unreliable, and message-based protocol. It is suitable for applications where speed is critical and some data loss is acceptable.</p>"},{"location":"chapters/9_tcpudp/#key-udp-features","title":"Key UDP Features:","text":"<ul> <li>No connection setup</li> <li>No guarantee of delivery or order</li> <li>Low overhead and latency</li> <li>Messages (datagrams) are sent as discrete packets</li> </ul>"},{"location":"chapters/9_tcpudp/#udp-communication-flow","title":"UDP Communication Flow:","text":"<ol> <li>No connection is established.</li> <li>Data is sent with <code>sendto()</code> and received with <code>recvfrom()</code>.</li> </ol>"},{"location":"chapters/9_tcpudp/#tcp-vs-udp-comparison","title":"TCP vs. UDP Comparison","text":"Feature TCP UDP Connection Yes No Reliable Yes No Ordered Yes No Flow Control Yes No Overhead High Low Use Cases Web, FTP, Email DNS, Video Streaming, VoIP"},{"location":"chapters/9_tcpudp/#tcp-example-in-c","title":"TCP Example in C","text":"<pre><code>// TCP Server\nint server_fd = socket(AF_INET, SOCK_STREAM, 0);\nbind(server_fd, ...);\nlisten(server_fd, 5);\nint client_fd = accept(server_fd, NULL, NULL);\nsend(client_fd, \"TCP Hello\", 9, 0);\nclose(client_fd);\n</code></pre>"},{"location":"chapters/9_tcpudp/#udp-example-in-c","title":"UDP Example in C","text":"<pre><code>// UDP Server\nint sockfd = socket(AF_INET, SOCK_DGRAM, 0);\nbind(sockfd, ...);\nchar buffer[1024];\nrecvfrom(sockfd, buffer, sizeof(buffer), 0, ...);\nsendto(sockfd, \"UDP Hello\", 9, 0, ...);\n</code></pre>"},{"location":"chapters/9_tcpudp/#choosing-between-tcp-and-udp","title":"Choosing Between TCP and UDP","text":"Application Type Recommended Protocol File transfer, web services TCP Real-time video/audio, gaming UDP Remote shell, email TCP DNS queries, SNMP UDP"},{"location":"chapters/9_tcpudp/#considerations","title":"Considerations:","text":"<ul> <li>Use TCP when reliability and order are critical.</li> <li>Use UDP when speed matters more than reliability.</li> </ul>"},{"location":"chapters/9_tcpudp/#debugging-and-testing-tools","title":"Debugging and Testing Tools","text":"<ul> <li><code>netstat</code>: View active TCP/UDP connections</li> <li><code>tcpdump</code> / <code>wireshark</code>: Packet-level analysis</li> <li><code>nc</code> (netcat): Test TCP/UDP connections</li> <li><code>nmap</code>: Scan for open ports and services</li> </ul>"},{"location":"chapters/9_tcpudp/#interactive-quiz","title":"Interactive Quiz","text":"<ol> <li> <p>Which protocol guarantees ordered delivery of data?</p> <p>A. UDP B. TCP C. ICMP</p> Show Answer <p>The correct answer is B. TCP provides reliable and ordered delivery.</p> </li> <li> <p>Which function is typically used to send a UDP message in C?</p> <p>A. <code>connect()</code> B. <code>sendto()</code> C. <code>write()</code></p> Show Answer <p>The correct answer is B. UDP uses <code>sendto()</code> and <code>recvfrom()</code>.</p> </li> <li> <p>Which protocol would be best for live video streaming?</p> <p>A. TCP B. UDP C. FTP</p> Show Answer <p>The correct answer is B. UDP is often used for real-time streaming where speed is prioritized over reliability.</p> </li> </ol>"},{"location":"chapters/9_tcpudp/#summary","title":"Summary","text":"<ul> <li>TCP is reliable, connection-oriented, and suited for data integrity.</li> <li>UDP is fast, connectionless, and suited for real-time applications.</li> <li>The choice between TCP and UDP depends on application needs.</li> <li>Tools like <code>netstat</code>, <code>tcpdump</code>, and <code>nc</code> help analyze network behavior.</li> </ul> <p>In the next chapter, we\u2019ll dive into Threads, a concurrency mechanism that enables parallel execution within a process.</p> <p>This chapter is based on material from \"Advanced Programming in the UNIX Environment, Third Edition, by W. Richard Stevens and Stephen A. Rago, 2013.\"</p>"},{"location":"projects/proj1/","title":"Project 1: minitar - A Posix-Compatible Archive Utility","text":""},{"location":"projects/proj1/#source","title":"Source","text":"<p>This project was taken from CSCI 4061 Intro to Operating Systems at the University of Minnesota - Twin Cities [Fall 2024], taught by Jack Kolb.</p>"},{"location":"projects/proj1/#starter-code","title":"\ud83d\udce6 Starter Code","text":"<p>You can download the starter code here: proj1-code.zip</p> <p>Save the starter code under your <code>csci4061</code> directory, which should now look like this:</p> <pre><code>csci4061/\n\u251c\u2500\u2500 labs/\n\u2502   \u251c\u2500\u2500 lab01-code/\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 projects/\n    \u2514\u2500\u2500 proj1-code/\n</code></pre>"},{"location":"projects/proj1/#how-to-succeed-on-this-project","title":"\u2705 How to Succeed on This Project","text":"<ul> <li>Read the spec thoroughly. TAs may decline to help if you haven\u2019t.</li> <li>Understand the starter code. Know what each file does.</li> <li>Test independently. Don\u2019t rely solely on automated tests.</li> <li>Expect bugs. Stay patient and persistent.</li> <li>Start early. Avoid deadline pressure.</li> <li>Ask questions publicly on Piazza. This helps everyone.</li> <li>Know the late policy. No submissions accepted more than 48 hours late.</li> </ul>"},{"location":"projects/proj1/#introduction","title":"\ud83e\udded Introduction","text":"<p>In this project, you will implement a simplified version of the Unix <code>tar</code> utility called <code>minitar</code>. You\u2019ll work with C and the <code>stdio</code> library to: - Practice file I/O - Explore systems programming techniques - Build a Posix-compliant archive tool</p> <p>Your implementation will be able to: - Create and append to archives - Extract files - Interoperate with <code>tar</code></p>"},{"location":"projects/proj1/#makefile-commands","title":"\ud83d\udcbb Makefile Commands","text":"<pre><code>make                # Compile minitar\nmake clean          # Remove compiled files\nmake clean-tests    # Remove test output\nmake zip            # Create Gradescope zip\nmake test           # Run all test cases\nmake test testnum=5 # Run specific test\n</code></pre>"},{"location":"projects/proj1/#manual-testing-advice","title":"\ud83e\uddea Manual Testing Advice","text":"<ul> <li>Use your own test cases</li> <li>View archives using: <pre><code>xxd test.tar | less\n</code></pre></li> <li>Use <code>tar</code> for interoperability comparison</li> <li>Install <code>xxd</code> in Docker: <pre><code>apt update\napt install xxd\n</code></pre></li> </ul>"},{"location":"projects/proj1/#starter-code-files","title":"\ud83e\uddf0 Starter Code Files","text":"File Purpose Notes <code>Makefile</code> Build/tests Do not modify <code>file_list.h</code> / <code>file_list.c</code> Linked list support Do not modify <code>minitar.h</code> Archive headers Do not modify <code>minitar.c</code> Archive operations EDIT THIS <code>minitar_main.c</code> CLI logic EDIT THIS <code>testius</code> Test runner Do not modify <code>test_cases/</code> Sample inputs Do not modify <p>Only modify the files marked as EDIT.</p>"},{"location":"projects/proj1/#archive-format-overview","title":"\ud83d\udce6 Archive Format Overview","text":"<ul> <li>Each archive is made of 512-byte blocks</li> <li>Each file: 1 header block + content blocks</li> <li>Ends with two zero blocks</li> </ul>"},{"location":"projects/proj1/#tar_header-struct","title":"tar_header Struct","text":"<p>Defined in <code>minitar.h</code>, it uses octal-encoded strings for numeric fields.</p> <pre><code>char size[12];  // octal, null-terminated string\n</code></pre> <p>Use <code>fill_tar_header()</code> to generate headers.</p>"},{"location":"projects/proj1/#archive-operations","title":"\ud83d\ude80 Archive Operations","text":""},{"location":"projects/proj1/#create","title":"Create","text":"<p><pre><code>./minitar -c -f archive.tar file1 file2\n</code></pre> - Write header and data for each file - Add two-block footer</p>"},{"location":"projects/proj1/#append","title":"Append","text":"<p><pre><code>./minitar -a -f archive.tar newfile\n</code></pre> - Remove footer with <code>remove_trailing_bytes()</code> - Append new headers/data - Add new footer</p>"},{"location":"projects/proj1/#list","title":"List","text":"<p><pre><code>./minitar -t -f archive.tar\n</code></pre> - Print name of each file in archive - Stop when footer blocks are reached</p>"},{"location":"projects/proj1/#update","title":"Update","text":"<p><pre><code>./minitar -u -f archive.tar existingfile\n</code></pre> - Like append, but must already exist in archive - Error message if not: <pre><code>Error: One or more of the specified files is not already present in archive.\n</code></pre></p>"},{"location":"projects/proj1/#extract","title":"Extract","text":"<p><pre><code>./minitar -x -f archive.tar\n</code></pre> - Write out each member file - Only extract latest version if duplicates exist</p>"},{"location":"projects/proj1/#tips-assumptions","title":"\ud83d\udca1 Tips &amp; Assumptions","text":"<ul> <li>No nested directory support</li> <li>Use high-level I/O (<code>fopen</code>, not <code>open</code>)</li> <li>Use <code>memset()</code>, <code>fseek()</code>, <code>ftell()</code></li> <li>Leverage <code>fill_tar_header()</code> and <code>file_list</code> utilities</li> </ul>"},{"location":"projects/proj1/#useful-c-functions","title":"Useful C Functions","text":"<ul> <li><code>fread()</code>, <code>fwrite()</code></li> <li><code>ftell()</code>, <code>fseek()</code></li> <li><code>sscanf()</code> for octal parsing</li> <li><code>perror()</code> for error reporting</li> </ul>"},{"location":"projects/proj1/#strategy-hints","title":"\ud83e\udde0 Strategy &amp; Hints","text":"<ul> <li>Reuse logic between operations</li> <li>Write helpers for block iteration</li> <li>Start early, debug often, test manually</li> <li>Avoid mixing <code>fopen()</code> and <code>open()</code></li> </ul>"},{"location":"projects/proj1/#summary","title":"\ud83d\udccc Summary","text":"<p>This project is your first big opportunity to apply systems-level thinking and build a utility that mirrors a well-known Unix tool. You'll practice file I/O, struct management, and command-line parsing \u2014 and develop habits that will serve you in all future OS coursework.</p> <p>Ready to begin? Download the starter code and get coding!</p>"},{"location":"sims/file-system-access/","title":"File System Access","text":"<p>Run the MicroSim</p>"},{"location":"sims/learning-graph/","title":"Learning Graph for Introduction to Operating Systems Course","text":"<p>Run Learning Graph MicroSim</p>"},{"location":"sims/process-tree/","title":"Process Tree","text":"<p>Run the MicroSim</p>"},{"location":"sims/virtual-memory-mapping/","title":"Virtual Memory Mapping","text":"<p>Run the MicroSim</p>"},{"location":"sims/wordcloud/","title":"Wordcloud","text":"<p>Run the MicroSim</p>"}]}